<!DOCTYPE html>
<html>
   <head>
      <meta charset=utf-8>
      <script src=fake-wake-lock.js></script>
   </head>
   <body>
      <style>
body {
   font-family: sans-serif;
   background-color: #333;
   -overflow: hidden;
}
#e_display {
   -border: solid 1px green;
   position: absolute;
   top: 0;
   left: 0;
   width: 100vw;
   height: 100vh;
}
#e_status {
   background-color: #000;
   border: solid 1px red;
   color: #aaa;
   position: absolute;
   padding: 0.5em;
   left: 1em;
   top: 1em;
   opacity: 0;
}
#e_note {
   border: solid 2px #0007;
   -border: solid 1px orange;
   background-color: #2227;
   position: absolute;
   padding: 1em;
   left: 10vh;
   max-width: calc(100vw - 20vh - 2em);
   bottom: 5vh;
   -min-height: 10vh;
   white-space: pre-wrap;
   font-size: 1.1em;
   font-weight: bold;
   color: #000;
	text-shadow: 0 0 0.8em #fff,
                0 0 0.4em #fff,
                0 0 0.4em #fff;
}
#e_header {
   -padding: 8px;
   background-color: #555;
}
#e_slides_info {
   background-color: #252;
}
#e_slides_links {
   background-color: #555;
}
      </style>
      <div id=e_header>
         List file:<input id=e_list_file type=file>
         <br>
         <span id=e_slides_info>0 slides loaded</span>
         <br>
         <ol id=e_slides_links>
           <li>1: foo.jpg
           <li>2: bar.mp4
           <li>3: tac.html
         </ol>
         <hr>
      </div>
      <div id=e_display></div>
      <div id=e_status></div>
      <div id=e_note></div>
      <script>

async function file_as_text(file) {
   const fr = new FileReader();
   return await new Promise((yes, no) => {
      fr.onloadend = () => {
         if (fr.error) {
            no(fr.error);
         } else {
            yes(fr.result);
         }
      };
      fr.readAsText(file);
   });
}

function umod(val, div) {
   val = val % div;
   if (val < 0) {
      val += div;
   }
   return val;
}

function remove_children(elem) {
   while (elem.firstChild) {
      elem.removeChild(elem.firstChild);
   }
}

function add_child_tag(parent, tag) {
   return parent.appendChild(document.createElement(tag));
}

// -

async function wake_forever(refresh_every_n_seconds = 10) {
   while (true) {
      try {
         const lock = await navigator.wakeLock.request();
         await new Promise(go => {
            setTimeout(go, refresh_every_n_seconds*1000);
         });
         await lock.release();
      } catch (e) {}
   }
}
wake_forever();

// -

SLIDE_DUR_MS = 10 * 1000;
DEFAULT_LIST_URL = 'slides/list.txt';

const G = {
   url_list: [],
   slide_id: 1, // one-based
};

const MEDIA_TYPE_BY_FILE_EXT = {
   '.gif': 'img',
   '.jpg': 'img',
   '.mp4': 'video',
   '.png': 'img',
};

function ext_from_url(url) {
   const last_ext = url.match(/\.[^\.]+$/)[0];
   return last_ext;
}

async function after_reflow(fn) {
   await new Promise(requestAnimationFrame);
   await new Promise(requestAnimationFrame);
   return await fn();
}

async function set_slide(id) {
   //console.log('set_slide', ...arguments);
   const id_inc = (id >= G.slide_id) ? 1 : -1;

   // Set next_slide_time first in case anything goes wrong, so that we continue
   // to the next slide.
   SLIDE_DUR_MS.defined;
   function reset_next_slide_time() {
      G.next_slide_time = performance.now() + SLIDE_DUR_MS;
   }
   reset_next_slide_time();

   // -

   await ensure_url_list();

   // -

   let elem;
   while (true) {
      G.slide_id = umod(id-1, G.url_list.length)+1;
      const slide_desc = G.url_list[G.slide_id-1];
      const url = slide_desc.url;
      const date = new Date();
      const time = date.toLocaleTimeString();
      const status = `${G.slide_id}/${G.url_list.length}: ${url}`;
      console.log(`[${time}] ${status}`);

      e_note.innerHTML = slide_desc.desc;
      e_note.style.transition = '';
      e_note.style.opacity = 0;
      if (e_note.innerHTML) {
         after_reflow(() => {
            e_note.style.transition = 'opacity 0.5s 2s ease-out';
            e_note.style.opacity = 1;
         });
      }

      e_status.textContent = status;

      const ext = ext_from_url(url);
      const mt = MEDIA_TYPE_BY_FILE_EXT[ext];
      switch (mt) {
      case 'img':
         elem = document.createElement('img');
         elem.src = url;
         elem.title = status;
         try {
            await elem.decode();
         } catch (e) {
            console.warn(`Skipping failing url '${url}':`, e);
            elem = null;
         }
         break;
      case 'video':
         elem = document.createElement('video');
         elem.src = url;
         elem.title = status;
         elem.muted = true; // So that autoplay works
         elem.loop = true;
         try {
            await elem.play();
         } catch (e) {
            console.warn(`Skipping failing url '${url}':`, e);
            elem = null;
         }
         break;
      default:
         console.warn(`Skipping file ext '${ext}' for ${url}...`);
         break;
      }
      if (!elem) {
         reset_next_slide_time(); // Keep resetting if skipping
         id += id_inc;
         continue;
      }
      break;
   }

   set_media(elem);
}

function set_media(elem) {
   //console.log('set_media', ...arguments);

   // style
   //const aspect_ratio = elem.naturalWidth / elem.naturalHeight;
   //elem.style.aspectRatio = aspect_ratio;
   elem.style.width = '100%';
   elem.style.height = '100%';
   elem.style.objectFit = 'contain';
   //elem.style.objectPosition: 'center';
   //elem.style.margin = 'auto';

   // clear and show
   remove_children(e_display);
   e_display.appendChild(elem);
}

document.addEventListener('keydown', async (e) => {
   const inc_slide = async d_id => {
      e_status.style.transition = '';
      e_status.style.opacity = 1;
      after_reflow(() => {
         e_status.style.transition = 'opacity 2s ease-in';
         e_status.style.opacity = 0;
      });

      await set_slide(G.slide_id+d_id);
   };

   switch (e.key) {
   case "ArrowLeft":
      inc_slide(-1);
      break;
   case "ArrowRight":
      inc_slide(+1);
      break;
   case "ArrowUp":
      e_note.style.transition = '';
      if (e_note.innerHTML) {
         e_note.style.opacity = 0.999; // If 1.0 it sees no change and continues the old transition.
      }
      break;
   case "ArrowDown":
      e_note.style.transition = '';
      e_note.style.opacity = 0.001;
      break;
   }
});

function parse_url_list(list_url, text) {
   text = text.replaceAll('\r', '');

   let list = text.split('\n');
   let line_num = 0;
   list = list.map(x => {
      line_num += 1;
      x = x.trim();
      if (!x || x.startsWith('#')) return null;

      let space_pos = x.indexOf(' ');
      if (space_pos == -1) {
         space_pos = x.length;
      }
      const slide_desc = {
         url: x.slice(0, space_pos),
         line_num: line_num,
         desc: '',
      };

      // -

      let extra = x.slice(space_pos+1).trim();
      if (extra[0] == '{') {
         try {
            extra = JSON.parse(extra);
         } catch (e) {
            console.warning(`[${list_url}:${line_num}] JSON.parse failed for '${extra}':`, e);
            return null;
         }
         for (const [k,v] of Object.entries(extra)) {
            if (slide_desc[k] === undefined) {
               console.warning(`[${list_url}:${line_num}] Invalid key '${k}' ignored, not in [${ Object.keys(slide_desc).join(', ') }]`);
               continue;
            }
            slide_desc[k] = v;
         }
      } else {
         slide_desc.desc = extra;
      }
      slide_desc.desc = slide_desc.desc.replaceAll('\\n', '\n');

      // -

      const ext = ext_from_url(slide_desc.url);
      const mt = MEDIA_TYPE_BY_FILE_EXT[ext];
      if (!mt) {
         console.warning(`[${list_url}:${line_num}] Ignoring unhandled ext '${ext}' for '${slide_desc.url}'.`);
         return null;
      }

      return slide_desc;
   });

   list = list.filter(x => x != null);
   if (!list) throw `parse_url_list(${list_url}) -> []`;

   return list;
}

function set_url_list(url_list) {
   console.log('set_url_list', ...arguments);

   G.url_list = url_list;
   e_slides_info.textContent = `${G.url_list.length} slides: `;

   setTimeout(() => {
      e_header.hidden = true;
   }, 1500);

   remove_children(e_slides_links);
   for (const slide_desc of G.url_list) {
      const li = add_child_tag(e_slides_links, 'li');
      li.textContent = slide_desc.url;
   }
}

async function ensure_url_list() {
   if (G.url_list.length) return;
   const list_url = DEFAULT_LIST_URL;
   const res = await fetch(list_url);
   const text = await res.text();

   const url_list = parse_url_list(list_url, text);
   set_url_list(url_list);
}

(async () => {
   await ensure_url_list();

   set_slide(1);

   while (true) {
      while (true) {
         const remaining = G.next_slide_time - performance.now();
         if (remaining < 100) break;
         //console.log(`[sleeping for ${remaining}ms...]`);
         await new Promise(go => setTimeout(go, remaining));
      }

      set_slide(G.slide_id+1);

      continue;
   }
})();

e_list_file.addEventListener('input', async () => {
   console.assert(e_list_file.files.length == 1);
   if (!e_list_file.files.length) return;
   const file = e_list_file.files[0];
   const text = await file_as_text(file);

   const url_list = parse_url_list(file.name, text);
   set_url_list(url_list);
   set_slide(1);
});

function toggle_header() {
   e_header.hidden = !e_header.hidden;
}

e_display.addEventListener('click', toggle_header);
e_slides_info.addEventListener('click', toggle_header);

      </script>
   </body>
</html>
